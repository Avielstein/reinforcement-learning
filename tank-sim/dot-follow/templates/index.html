<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üê† Dot Follow RL - Web Interface</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            margin-bottom: 30px;
        }

        .simulation-area {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            position: relative;
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            height: fit-content;
        }

        canvas {
            background: #001122;
            border-radius: 10px;
            border: 2px solid #4a90e2;
            display: block;
            margin: 0 auto;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .control-group h3 {
            margin: 0 0 15px 0;
            color: #ffd700;
            font-size: 1.1em;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .primary-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .secondary-btn {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
        }

        .danger-btn {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
        }

        .pattern-btn {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            color: white;
            flex: 1;
            min-width: 80px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #e0e0e0;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="file"] {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            margin-bottom: 10px;
        }

        .value-display {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 5px;
            border-radius: 5px;
            font-weight: bold;
            color: #ffd700;
        }

        .stats {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }

        .stats div {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        .status-indicator {
            padding: 8px 12px;
            border-radius: 5px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }

        .status-loaded {
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid #4CAF50;
        }

        .status-none {
            background: rgba(158, 158, 158, 0.3);
            border: 1px solid #9E9E9E;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .info-panel h4 {
            margin: 0 0 10px 0;
            color: #ffd700;
        }

        .info-panel p {
            margin: 5px 0;
            font-size: 0.9em;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üê† Dot Follow Reinforcement Learning</h1>
        
        <div class="info-panel">
            <h4>üìã Instructions</h4>
            <p><strong>1. Train Model:</strong> Use Python scripts to train models (simple_demo.py creates best_dot_follow_circular.pt)</p>
            <p><strong>2. Load Model:</strong> Upload the trained .pt model file using the file input below</p>
            <p><strong>3. Test & Tune:</strong> Adjust parameters and watch how the fish behaves with different settings</p>
            <p><strong>4. Fine-tune:</strong> Use the web interface to test different movement patterns and speeds</p>
        </div>

        <div class="main-content">
            <div class="simulation-area">
                <canvas id="tankCanvas" width="700" height="700"></canvas>
                
                <div class="chart-container">
                    <h3>üìà Performance Metrics</h3>
                    <canvas id="metricsChart" width="660" height="200"></canvas>
                </div>
            </div>

            <div class="controls-panel">
                <div class="control-group">
                    <h3>üß† Model Management</h3>
                    <div id="modelStatus" class="status-indicator status-none">
                        No Model Loaded
                    </div>
                    <input type="file" id="modelFile" accept=".pt" />
                    <button onclick="loadModel()" class="secondary-btn" style="width: 100%;">
                        Load Model
                    </button>
                </div>

                <div class="control-group">
                    <h3>üéÆ Simulation Control</h3>
                    <div class="button-group">
                        <button onclick="controlSimulation('start')" class="primary-btn">‚ñ∂Ô∏è Start</button>
                        <button onclick="controlSimulation('pause')" class="secondary-btn">‚è∏Ô∏è Pause</button>
                        <button onclick="controlSimulation('reset')" class="danger-btn">üîÑ Reset</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üéØ Movement Patterns</h3>
                    <div class="button-group">
                        <button onclick="setPattern('circular')" class="pattern-btn">üîÑ Circular</button>
                        <button onclick="setPattern('figure8')" class="pattern-btn">‚àû Figure-8</button>
                    </div>
                    <div class="button-group">
                        <button onclick="setPattern('random_walk')" class="pattern-btn">üé≤ Random</button>
                        <button onclick="setPattern('zigzag')" class="pattern-btn">‚ö° Zigzag</button>
                    </div>
                    <div class="button-group">
                        <button onclick="setPattern('spiral')" class="pattern-btn">üåÄ Spiral</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>‚öôÔ∏è Environment Parameters</h3>
                    
                    <div class="slider-container">
                        <label for="targetSpeed">Target Speed:</label>
                        <input type="range" id="targetSpeed" min="2" max="20" step="0.5" value="8" 
                               oninput="updateParameter('target_speed', this.value)">
                        <div class="value-display" id="targetSpeedValue">8.0</div>
                    </div>

                    <div class="slider-container">
                        <label for="targetRadius">Pattern Size:</label>
                        <input type="range" id="targetRadius" min="10" max="40" step="1" value="20"
                               oninput="updateParameter('target_radius', this.value)">
                        <div class="value-display" id="targetRadiusValue">20</div>
                    </div>

                    <div class="slider-container">
                        <label for="currentStrength">Water Current:</label>
                        <input type="range" id="currentStrength" min="0" max="8" step="0.1" value="2"
                               oninput="updateParameter('current_strength', this.value)">
                        <div class="value-display" id="currentStrengthValue">2.0</div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üß™ Model Parameters</h3>
                    
                    <div class="slider-container">
                        <label for="explorationNoise">Exploration Noise:</label>
                        <input type="range" id="explorationNoise" min="0" max="1" step="0.01" value="0.1"
                               oninput="updateParameter('exploration_noise', this.value)">
                        <div class="value-display" id="explorationNoiseValue">0.10</div>
                    </div>

                    <div class="slider-container">
                        <label for="actionScale">Action Scaling:</label>
                        <input type="range" id="actionScale" min="0.1" max="2" step="0.1" value="1"
                               oninput="updateParameter('action_scale', this.value)">
                        <div class="value-display" id="actionScaleValue">1.0</div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üìä Statistics</h3>
                    <div class="stats">
                        <div>Episode: <span id="episodeCount">0</span></div>
                        <div>Steps: <span id="stepCount">0</span></div>
                        <div>Reward: <span id="currentReward">0.0</span></div>
                        <div>Distance: <span id="targetDistance">0.0</span></div>
                        <div>Fish Speed: <span id="fishSpeed">0.0</span></div>
                        <div>Pattern: <span id="currentPattern">circular</span></div>
                        <div>Model: <span id="modelLoaded">None</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let canvas, ctx, metricsCanvas, metricsCtx;
        let animationId;
        
        // Initialize
        window.onload = function() {
            canvas = document.getElementById('tankCanvas');
            ctx = canvas.getContext('2d');
            metricsCanvas = document.getElementById('metricsChart');
            metricsCtx = metricsCanvas.getContext('2d');
            
            // Start polling for state updates
            setInterval(updateState, 100); // 10 FPS
        };

        // API calls
        async function updateState() {
            try {
                const response = await fetch('/api/state');
                const state = await response.json();
                updateDisplay(state);
            } catch (error) {
                console.error('Error fetching state:', error);
            }
        }

        async function controlSimulation(action) {
            try {
                const response = await fetch(`/api/control/${action}`, { method: 'POST' });
                const result = await response.json();
                if (!result.success) {
                    alert(result.message);
                }
            } catch (error) {
                console.error('Error controlling simulation:', error);
            }
        }

        async function setPattern(pattern) {
            try {
                const response = await fetch(`/api/pattern/${pattern}`, { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    // Visual feedback
                    document.querySelectorAll('.pattern-btn').forEach(btn => {
                        btn.style.opacity = '0.7';
                    });
                    event.target.style.opacity = '1';
                }
            } catch (error) {
                console.error('Error setting pattern:', error);
            }
        }

        async function updateParameter(param, value) {
            try {
                const params = {};
                params[param] = parseFloat(value);
                
                const response = await fetch('/api/params', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(params)
                });
                
                // Update display
                const displayId = param.replace('_', '') + 'Value';
                const element = document.getElementById(displayId);
                if (element) {
                    element.textContent = parseFloat(value).toFixed(param.includes('noise') || param.includes('scale') ? 2 : 1);
                }
            } catch (error) {
                console.error('Error updating parameter:', error);
            }
        }

        async function loadModel() {
            const fileInput = document.getElementById('modelFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a model file first');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                const response = await fetch('/api/model/load', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                if (result.success) {
                    document.getElementById('modelStatus').textContent = `Loaded: ${file.name}`;
                    document.getElementById('modelStatus').className = 'status-indicator status-loaded';
                    alert('Model loaded successfully!');
                } else {
                    alert('Error loading model: ' + result.message);
                }
            } catch (error) {
                console.error('Error loading model:', error);
                alert('Error loading model: ' + error.message);
            }
        }

        // Display functions
        function updateDisplay(state) {
            drawSimulation(state);
            drawMetrics(state);
            updateStats(state);
        }

        function drawSimulation(state) {
            const scale = canvas.width / 100; // Scale from 100x100 to canvas size
            
            // Clear canvas
            ctx.fillStyle = '#001122';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw water currents
            state.currents.forEach(current => {
                // Current influence area
                ctx.beginPath();
                ctx.arc(current.x * scale, current.y * scale, current.radius * scale, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
                ctx.fill();
                
                // Current direction arrow
                const arrowLength = current.strength * 3 * scale;
                const startX = current.x * scale;
                const startY = current.y * scale;
                const endX = startX + Math.cos(current.direction) * arrowLength;
                const endY = startY + Math.sin(current.direction) * arrowLength;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
            
            // Draw connection line between fish and target
            ctx.beginPath();
            ctx.moveTo(state.fish.x * scale, state.fish.y * scale);
            ctx.lineTo(state.target.x * scale, state.target.y * scale);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw target
            ctx.beginPath();
            ctx.arc(state.target.x * scale, state.target.y * scale, 8, 0, 2 * Math.PI);
            ctx.fillStyle = '#ff4444';
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw fish
            ctx.beginPath();
            ctx.arc(state.fish.x * scale, state.fish.y * scale, 10, 0, 2 * Math.PI);
            ctx.fillStyle = '#4444ff';
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw fish velocity vector
            const velScale = 5;
            const fishX = state.fish.x * scale;
            const fishY = state.fish.y * scale;
            const velEndX = fishX + state.fish.vx * velScale;
            const velEndY = fishY + state.fish.vy * velScale;
            
            ctx.beginPath();
            ctx.moveTo(fishX, fishY);
            ctx.lineTo(velEndX, velEndY);
            ctx.strokeStyle = '#44ff44';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function drawMetrics(state) {
            const width = metricsCanvas.width;
            const height = metricsCanvas.height;
            
            // Clear canvas
            metricsCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            metricsCtx.fillRect(0, 0, width, height);
            
            if (state.history.rewards.length < 2) return;
            
            const maxPoints = 50;
            const pointWidth = width / maxPoints;
            
            // Draw reward history
            metricsCtx.strokeStyle = '#4CAF50';
            metricsCtx.lineWidth = 2;
            metricsCtx.beginPath();
            
            const rewards = state.history.rewards;
            const maxReward = Math.max(...rewards, 1);
            const minReward = Math.min(...rewards, 0);
            const rewardRange = maxReward - minReward || 1;
            
            for (let i = 0; i < rewards.length; i++) {
                const x = i * pointWidth;
                const y = height - ((rewards[i] - minReward) / rewardRange) * height;
                
                if (i === 0) {
                    metricsCtx.moveTo(x, y);
                } else {
                    metricsCtx.lineTo(x, y);
                }
            }
            metricsCtx.stroke();
            
            // Draw distance history
            metricsCtx.strokeStyle = '#FF5722';
            metricsCtx.lineWidth = 2;
            metricsCtx.beginPath();
            
            const distances = state.history.distances;
            const maxDistance = Math.max(...distances, 1);
            
            for (let i = 0; i < distances.length; i++) {
                const x = i * pointWidth;
                const y = height - (distances[i] / maxDistance) * height;
                
                if (i === 0) {
                    metricsCtx.moveTo(x, y);
                } else {
                    metricsCtx.lineTo(x, y);
                }
            }
            metricsCtx.stroke();
        }

        function updateStats(state) {
            document.getElementById('episodeCount').textContent = state.stats.episode;
            document.getElementById('stepCount').textContent = state.stats.step_count;
            document.getElementById('currentReward').textContent = state.stats.current_reward;
            document.getElementById('targetDistance').textContent = state.stats.target_distance;
            document.getElementById('fishSpeed').textContent = state.stats.fish_speed;
            document.getElementById('currentPattern').textContent = state.stats.pattern;
            document.getElementById('modelLoaded').textContent = state.stats.model_loaded ? 'Loaded' : 'None';
        }
    </script>
</body>
</html>
